<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppZmqZoltanExt: zmqzext::poller_t Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CppZmqZoltanExt<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classzmqzext_1_1poller__t.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classzmqzext_1_1poller__t-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">zmqzext::poller_t Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for efficient polling of multiple ZMQ sockets.  
 <a href="classzmqzext_1_1poller__t.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="poller_8h_source.html">poller.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15bb28299a0895c2874ef115ed87caa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a15bb28299a0895c2874ef115ed87caa7">add</a> (zmq::socket_ref socket)</td></tr>
<tr class="memdesc:a15bb28299a0895c2874ef115ed87caa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a socket to the polling set.  <br /></td></tr>
<tr class="separator:a15bb28299a0895c2874ef115ed87caa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d22804dc5ad352c25e831033bf771d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a93d22804dc5ad352c25e831033bf771d">remove</a> (zmq::socket_ref socket)</td></tr>
<tr class="memdesc:a93d22804dc5ad352c25e831033bf771d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a socket from the polling set.  <br /></td></tr>
<tr class="separator:a93d22804dc5ad352c25e831033bf771d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4bb2a0c8b357590077f7e22589e967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a4a4bb2a0c8b357590077f7e22589e967">set_interruptible</a> (bool interruptible) noexcept</td></tr>
<tr class="memdesc:a4a4bb2a0c8b357590077f7e22589e967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether polling should be interruptible.  <br /></td></tr>
<tr class="separator:a4a4bb2a0c8b357590077f7e22589e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e13f136c93bc4e482493dea42ab989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a29e13f136c93bc4e482493dea42ab989">is_interruptible</a> () const noexcept</td></tr>
<tr class="memdesc:a29e13f136c93bc4e482493dea42ab989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if polling is interruptible.  <br /></td></tr>
<tr class="separator:a29e13f136c93bc4e482493dea42ab989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8996aeeb7ea7cf96854278393d3bf516"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a8996aeeb7ea7cf96854278393d3bf516">size</a> () const noexcept</td></tr>
<tr class="memdesc:a8996aeeb7ea7cf96854278393d3bf516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of sockets in the polling set.  <br /></td></tr>
<tr class="separator:a8996aeeb7ea7cf96854278393d3bf516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73b6ec075d51f37cc974a873bf0d246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#aa73b6ec075d51f37cc974a873bf0d246">terminated</a> () const noexcept</td></tr>
<tr class="memdesc:aa73b6ec075d51f37cc974a873bf0d246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the poller has been terminated during the last wait operation.  <br /></td></tr>
<tr class="separator:aa73b6ec075d51f37cc974a873bf0d246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246ea1594b46fe44dad0245035622bcb"><td class="memItemLeft" align="right" valign="top">zmq::socket_ref&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a246ea1594b46fe44dad0245035622bcb">wait</a> (std::chrono::milliseconds timeout=std::chrono::milliseconds{-1})</td></tr>
<tr class="memdesc:a246ea1594b46fe44dad0245035622bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for any socket to become ready for receiving.  <br /></td></tr>
<tr class="separator:a246ea1594b46fe44dad0245035622bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae4dfae3b9646596ce2b58bfbdf080c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; zmq::socket_ref &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classzmqzext_1_1poller__t.html#a4ae4dfae3b9646596ce2b58bfbdf080c">wait_all</a> (std::chrono::milliseconds timeout=std::chrono::milliseconds{-1})</td></tr>
<tr class="memdesc:a4ae4dfae3b9646596ce2b58bfbdf080c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for at least one socket to become ready for receiving and return all ready.  <br /></td></tr>
<tr class="separator:a4ae4dfae3b9646596ce2b58bfbdf080c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for efficient polling of multiple ZMQ sockets. </p>
<p>The <a class="el" href="classzmqzext_1_1poller__t.html" title="Class for efficient polling of multiple ZMQ sockets.">poller_t</a> class provides a convenient wrapper around ZMQ's polling mechanism. It allows applications to monitor multiple sockets simultaneously and wait for data availability on any or all of them.</p>
<p>The poller supports adding and removing sockets to be monitored at any time.</p>
<p>When used in conjunction with the interrupt handling module and the application receives a SIINT or SIGTERM signal, the poller will return early from wait operations, allowing the application to handle the interrupt by checking if the poller was terminated.</p>
<p>The <a class="el" href="classzmqzext_1_1poller__t.html#a4a4bb2a0c8b357590077f7e22589e967" title="Set whether polling should be interruptible.">set_interruptible()</a> method can be used to enable or disable interrupt checking. When set to false (the default is true), the poller will still return early on interrupt signals, but the <a class="el" href="classzmqzext_1_1poller__t.html#aa73b6ec075d51f37cc974a873bf0d246" title="Check if the poller has been terminated during the last wait operation.">terminated()</a> method will always return false. This behavior may be desirable on actors when they should continue processing all events before receiving a stop request from the main application. So the main application can perform a graceful shutdown without the actors loosing any messages that are already in their queues.</p>
<dl class="section note"><dt>Note</dt><dd>This class is not thread-safe. </dd>
<dd>
On Windows, the waiting calls to ZMQ functions do not return early on signals, no matter if the signal handlers are installed or not. Still, the interrupt flag is set and can be checked by the poller. Then, it is very important to call the wait methods with an appropriate timeout to allow the poller to detect the interrupt within a reasonable time. </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8h_source.html#l00091">91</a> of file <a class="el" href="poller_8h_source.html">poller.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a15bb28299a0895c2874ef115ed87caa7" name="a15bb28299a0895c2874ef115ed87caa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bb28299a0895c2874ef115ed87caa7">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zmqzext::poller_t::add </td>
          <td>(</td>
          <td class="paramtype">zmq::socket_ref&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a socket to the polling set. </p>
<p>Registers a socket with the poller for monitoring. The socket will be polled in subsequent wait operations to detect readiness for receive operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The ZMQ socket reference to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the socket is invalid or already added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a93d22804dc5ad352c25e831033bf771d" title="Remove a socket from the polling set.">remove()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8cpp_source.html#l00045">45</a> of file <a class="el" href="poller_8cpp_source.html">poller.cpp</a>.</p>

</div>
</div>
<a id="a29e13f136c93bc4e482493dea42ab989" name="a29e13f136c93bc4e482493dea42ab989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e13f136c93bc4e482493dea42ab989">&#9670;&#160;</a></span>is_interruptible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zmqzext::poller_t::is_interruptible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if polling is interruptible. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the poller will check for interrupt signals, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a4a4bb2a0c8b357590077f7e22589e967" title="Set whether polling should be interruptible.">set_interruptible()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8h_source.html#l00150">150</a> of file <a class="el" href="poller_8h_source.html">poller.h</a>.</p>

</div>
</div>
<a id="a93d22804dc5ad352c25e831033bf771d" name="a93d22804dc5ad352c25e831033bf771d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d22804dc5ad352c25e831033bf771d">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void zmqzext::poller_t::remove </td>
          <td>(</td>
          <td class="paramtype">zmq::socket_ref&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a socket from the polling set. </p>
<p>Unregisters a socket from the poller. The socket will no longer be monitored in wait operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The ZMQ socket reference to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Removing a socket that was not added is a no-op </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a15bb28299a0895c2874ef115ed87caa7" title="Add a socket to the polling set.">add()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8cpp_source.html#l00057">57</a> of file <a class="el" href="poller_8cpp_source.html">poller.cpp</a>.</p>

</div>
</div>
<a id="a4a4bb2a0c8b357590077f7e22589e967" name="a4a4bb2a0c8b357590077f7e22589e967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4bb2a0c8b357590077f7e22589e967">&#9670;&#160;</a></span>set_interruptible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void zmqzext::poller_t::set_interruptible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interruptible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether polling should be interruptible. </p>
<p>Controls whether the poller will check for interrupt signals during wait operations.</p>
<p>When enabled (default), the poller wait operations will return immediately if an interrupt signal was already received, or return early if an interrupt signal is received during the wait operations. The is_terminated() will then return true.</p>
<p>When interruptible is disabled, the wait operations are allowed to wait for incoming messages in the monitored sockets even if an interrupt signal was already received. Still, the wait operations will return early if an interrupt signal is received during the wait. The is_terminated() method will always return false, even if an interrupt signal was received. This behavior may be desirable on actors when they should continue processing all events before receiving a stop request from the main application. So the main application can perform a graceful shutdown without the actors loosing any messages that are already in their queues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptible</td><td>true to enable interrupt checking, false otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Interrupt checking requires <a class="el" href="interrupt_8h.html#a8a372053d87242d2e192cdb3e4cd2e4e" title="Install signal handlers for SIGINT and SIGTERM.">install_interrupt_handler()</a> to be called </dd>
<dd>
Default is true </dd>
<dd>
Setting to false does not disable early return on interrupts </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a29e13f136c93bc4e482493dea42ab989" title="Check if polling is interruptible.">is_interruptible()</a> </dd>
<dd>
<a class="el" href="interrupt_8h.html#a8a372053d87242d2e192cdb3e4cd2e4e" title="Install signal handlers for SIGINT and SIGTERM.">install_interrupt_handler()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8h_source.html#l00142">142</a> of file <a class="el" href="poller_8h_source.html">poller.h</a>.</p>

</div>
</div>
<a id="a8996aeeb7ea7cf96854278393d3bf516" name="a8996aeeb7ea7cf96854278393d3bf516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8996aeeb7ea7cf96854278393d3bf516">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t zmqzext::poller_t::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of sockets in the polling set. </p>
<dl class="section return"><dt>Returns</dt><dd>The count of registered sockets </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8h_source.html#l00157">157</a> of file <a class="el" href="poller_8h_source.html">poller.h</a>.</p>

</div>
</div>
<a id="aa73b6ec075d51f37cc974a873bf0d246" name="aa73b6ec075d51f37cc974a873bf0d246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73b6ec075d51f37cc974a873bf0d246">&#9670;&#160;</a></span>terminated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool zmqzext::poller_t::terminated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the poller has been terminated during the last wait operation. </p>
<p>Returns whether a termination condition has been detected during the last wait operation. The termination condition occurs when an interrupt signal is received and the poller is interruptible or when the context associated with any of the monitored sockets is terminated.</p>
<p>The terminated state is reset on each wait operation so a new wait can be performed after receiving an interrupt signal when the interruptible mode is disabled.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the poller is in a terminated state, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a4a4bb2a0c8b357590077f7e22589e967" title="Set whether polling should be interruptible.">set_interruptible()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8h_source.html#l00174">174</a> of file <a class="el" href="poller_8h_source.html">poller.h</a>.</p>

</div>
</div>
<a id="a246ea1594b46fe44dad0245035622bcb" name="a246ea1594b46fe44dad0245035622bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246ea1594b46fe44dad0245035622bcb">&#9670;&#160;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">zmq::socket_ref zmqzext::poller_t::wait </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds{-1}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for any socket to become ready for receiving. </p>
<p>Blocks until at least one socket becomes ready for receiving, the timeout expires, an interrupt signal is received or the context associated with any of the monitored sockets is terminated. Returns the first ready socket found.</p>
<p>Sockets are checked in the order they were added to the poller. If multiple sockets are ready, the first one is returned. If the same socket is always ready, it may starve other sockets. For fairness, consider using <a class="el" href="classzmqzext_1_1poller__t.html#a4ae4dfae3b9646596ce2b58bfbdf080c" title="Wait for at least one socket to become ready for receiving and return all ready.">wait_all()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum wait duration in milliseconds (default: -1 for infinite timeout) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first socket that is ready for I/O</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">zmq::error_t</td><td>if a ZMQ error occurs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When interrupted, it returns early, no matter the interruptible setting </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a4ae4dfae3b9646596ce2b58bfbdf080c" title="Wait for at least one socket to become ready for receiving and return all ready.">wait_all()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8cpp_source.html#l00064">64</a> of file <a class="el" href="poller_8cpp_source.html">poller.cpp</a>.</p>

</div>
</div>
<a id="a4ae4dfae3b9646596ce2b58bfbdf080c" name="a4ae4dfae3b9646596ce2b58bfbdf080c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae4dfae3b9646596ce2b58bfbdf080c">&#9670;&#160;</a></span>wait_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; zmq::socket_ref &gt; zmqzext::poller_t::wait_all </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>std::chrono::milliseconds{-1}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for at least one socket to become ready for receiving and return all ready. </p>
<p>Blocks until at least one socket becomes ready for receiving, the timeout expires, an interrupt signal is received or the context associated with any of the monitored sockets is terminated. Returns all ready sockets at the time of the check.</p>
<p>Sockets are checked in the order they were added to the poller. If multiple sockets are ready, all of them are returned in the order they were added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Maximum wait duration in milliseconds (default: -1 for infinite timeout) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of references to all ready sockets</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">zmq::error_t</td><td>if a ZMQ error occurs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When interrupted, it returns early, no matter the interruptible setting </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classzmqzext_1_1poller__t.html#a246ea1594b46fe44dad0245035622bcb" title="Wait for any socket to become ready for receiving.">wait()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="poller_8cpp_source.html#l00101">101</a> of file <a class="el" href="poller_8cpp_source.html">poller.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cppzmqzoltanext/<a class="el" href="poller_8h_source.html">poller.h</a></li>
<li>src/<a class="el" href="poller_8cpp_source.html">poller.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>zmqzext</b></li><li class="navelem"><a class="el" href="classzmqzext_1_1poller__t.html">poller_t</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
